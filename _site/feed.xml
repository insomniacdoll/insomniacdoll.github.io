<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-07-19T11:40:02+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">零時寝子</title><subtitle>Focus on Bigdata Engineering, AI and Data Mining </subtitle><entry><title type="html">使用osquery进行系统监控和系统数据收集（1）</title><link href="http://localhost:4000/2015/05/28/use-osquery-to-monitor-and-collect-os-data.html" rel="alternate" type="text/html" title="使用osquery进行系统监控和系统数据收集（1）" /><published>2015-05-28T00:00:00+08:00</published><updated>2015-05-28T00:00:00+08:00</updated><id>http://localhost:4000/2015/05/28/use-osquery-to-monitor-and-collect-os-data</id><content type="html" xml:base="http://localhost:4000/2015/05/28/use-osquery-to-monitor-and-collect-os-data.html"><![CDATA[<h3 id="0-前言">0. 前言</h3>

<p>系统的实时监控系统，在技术上的选择并不少，比如商业的<a href="http://newrelic.com/">New Relic</a>，或者开源的<a href="">collectd</a>配合<a href="http://influxdb.com/">InfluxDB</a>+<a href="http://grafana.org/">Grafana</a>，都可以快捷迅速地解决需求。<br />
本文介绍另外一种可能性，即osquery，它是facebook开源的一个项目，它将操作系统的各类资源看作一个RDBMS，允许开发者或者运维人员使用类SQL语言去查询系统数据。每一类系统资源都被抽象成一个有名数据库表，比如进程、已加载的内核模块、活动的网络链接、浏览器插件甚至硬件设备事件。<br />
第一篇文章作为入门教程，仅介绍安装和基本使用。</p>

<h3 id="1-安装">1. 安装</h3>

<p>对于各类Linux发行版以及OSX，osquery已经有了直接的二进制安装包，直接使用包管理器进行安装即可。另外OSX在homebrew中也已经发布，可以直接使用brew进行安装。<br />
下面介绍一下Linux下从源码编译安装的方法。<br />
首先是osquery的源代码，可以从github获取：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">  
git clone https://github.com/facebook/osquery.git  </code></pre></figure>

<p>然后根据官方文档，直接make deps会有问题，是因为thrift没有安装，找不到相应的库。<br />
于是需要先安装同样出自Facebook的thrift，它是一个跨语言的服务框架，可以通过接口定义语言（IDL），生成不同语言的服务器和客户端接口，开发者在其基础上就可以轻松编写一个跨语言的网络服务了。thrift的源代码可以从apache的相关页面获取：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">  
https://thrift.apache.org/download  </code></pre></figure>

<p>同样是编译安装，首先安装依赖包和C++语言支持（需要boost）：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">  
<span class="nb">sudo </span>apt-get <span class="nb">install </span>libboost1.55-all-dev g++ flex bison autoconf automake libtool pkg-config  </code></pre></figure>

<p>如果需要java语言支持，那么还需要ant、maven以及JDK，还需要配置好相应的环境变量。<br />
如果需要python语言支持，那么还需要python2.6以上的环境、pip以及python-dev软件包（包含开发头文件）。<br />
如果需要ruby语言支持，那么还需要gem和bundler包管理器。<br />
其他语言支持具体的需求可以参考thrift的<a href="https://thrift.apache.org/docs/install/">官方页面</a>。<br />
然后进入到thrift的源码目录，使用configure命令进行编译配置，此时可以用with-XXX或者without-XXX来制定相关语言的支持。值得说明的是，0.9.2版本的thrift的单元测试有问题，某些测试需要的三方资源并没有出现在相应目录里面，所以直接make会出现单测错误编译失败的情况。只要在configure的时候加入–without-tests参数跳过单测即可。<br />
然后就可以编译并安装：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">  
make  
make <span class="nb">install</span></code></pre></figure>

<p>然后在默认配置下，thrift相关的库就已经在/usr/local/lib中了。<br />
这时候回到osquery的目录，执行cmake . &amp;&amp; make deps，就会下载并编译其他依赖。值得说明的是，依赖库都在amazon的aws上，由于GFW的原因下载经常会断线，所以还是配置好一个可以顺利X墙的梯子。<br />
另外，在默认情况下，osquery编译的时候会到/usr/local/lib中找thrift相关的库，如果你没有把thrift安装到这里，那么需要配置THRIFT_HOME的环境变量。<br />
然后make &amp;&amp; make install，泡杯咖啡等着编译完毕即可。</p>

<h3 id="2-osquery的使用">2. osquery的使用</h3>

<p>如前言中所描述，osquery将计算机资源抽象成了数据库表，这些数据库表都是通过其内置的插件和API实现的。其中许多操作系统的内置资源抽象已经写好了，直接使用即可。下面看几个例子：<br />
首先用osqueryi命令进入解释器模式。
列出当前操作系统中所有的用户：</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql">  
<span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">users</span><span class="p">;</span>  </code></pre></figure>

<p>运行结果：<br />
<img src="http://localhost:4000/images/osquery/users.PNG" alt="Users Image" /><br />
列出所有进程：</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> 
<span class="k">SELECT</span>  <span class="n">pid</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">cmdline</span> <span class="k">FROM</span> <span class="n">processes</span><span class="p">;</span>  </code></pre></figure>

<p>运行结果：<br />
<img src="http://localhost:4000/images/osquery/process.PNG" alt="Process Image" /><br />
取得当前的进程名、PID以及该进程使用的端口：</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> 
<span class="k">SELECT</span> 
    <span class="k">DISTINCT</span> <span class="n">process</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">listening</span><span class="p">.</span><span class="n">port</span><span class="p">,</span> <span class="n">process</span><span class="p">.</span><span class="n">pid</span>
<span class="k">FROM</span> 
    <span class="n">processes</span> <span class="k">AS</span> <span class="n">process</span>
<span class="k">JOIN</span> 
    <span class="n">listening_ports</span> <span class="k">AS</span> <span class="n">listening</span> 
<span class="k">ON</span> 
    <span class="n">process</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">listening</span><span class="p">.</span><span class="n">pid</span>
<span class="k">WHERE</span> 
    <span class="n">listening</span><span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="s1">'0.0.0.0'</span><span class="p">;</span></code></pre></figure>

<p>取得当前系统中所有进程的打开文件的数量：</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> 
<span class="k">SELECT</span> 
    <span class="k">DISTINCT</span> <span class="n">process</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">process</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">path</span><span class="p">)</span> <span class="k">as</span> <span class="n">file_count</span>
<span class="k">FROM</span> 
    <span class="n">processes</span> <span class="k">AS</span> <span class="n">process</span>
<span class="k">JOIN</span> 
    <span class="n">process_open_files</span> <span class="n">f</span>
<span class="k">ON</span> 
    <span class="n">process</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">pid</span>
<span class="k">GROUP</span> <span class="k">BY</span>
    <span class="n">process</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> 
    <span class="n">process</span><span class="p">.</span><span class="n">pid</span><span class="p">;</span></code></pre></figure>

<p>运行结果：<br />
<img src="http://localhost:4000/images/osquery/files.PNG" alt="Files Image" /><br />
获取到可能异常的ARP请求（广播的mac地址数量大于1）：</p>

<figure class="highlight"><pre><code class="language-sql" data-lang="sql"> 
<span class="k">SELECT</span> 
    <span class="n">address</span><span class="p">,</span> <span class="n">mac</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="n">mac</span><span class="p">)</span> <span class="k">AS</span> <span class="n">mac_count</span>
<span class="k">FROM</span> 
    <span class="n">arp_cache</span> 
<span class="k">GROUP</span> <span class="k">BY</span> 
    <span class="n">mac</span>
<span class="k">HAVING</span> 
    <span class="k">count</span><span class="p">(</span><span class="n">mac</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span></code></pre></figure>

<p>可以看出，osquery的使用极大地依赖table。具体其内置的table说明，可以参看<a href="https://osquery.io/docs/tables/">官方文档</a>。至于怎么编写一个plugin支持新的table，后续的文章将会介绍。</p>

<h3 id="3-对比">3. 对比</h3>

<p>对比collectd，osquery最大的优势，就是不需要再去关心那些系统数据收集所以来的软件库了，一切都已经由插件帮我们做好，只需要用SQL语句就能轻松查看并且收集到系统的运行数据。<br />
另一方面，osquery目前还没有Grafana这样出色的前端来进行数据可视化的配合，collectd诸多功能强大的插件也是osquery所不具备的，整合成真正方便可用的产品，osquery还有路需要走。</p>

<h3 id="4-参考资料">4. 参考资料</h3>

<p>[1] https://github.com/facebook/osquery<br />
[2] https://osquery.io/docs<br />
[3] http://osquery.readthedocs.org/en/stable/development/building/<br />
[4] https://thrift.apache.org/</p>

<p>-EOF-</p>]]></content><author><name></name></author><category term="os" /><category term="kernel" /><category term="osquery" /><category term="thrift" /><summary type="html"><![CDATA[使用osquery进行系统监控和系统数据收集（1）]]></summary></entry><entry><title type="html">在My Cloud EX2上安装aria2和yaaw</title><link href="http://localhost:4000/2015/03/20/install-aria2-on-my-cloud-ex2.html" rel="alternate" type="text/html" title="在My Cloud EX2上安装aria2和yaaw" /><published>2015-03-20T00:00:00+08:00</published><updated>2015-03-20T00:00:00+08:00</updated><id>http://localhost:4000/2015/03/20/install-aria2-on-my-cloud-ex2</id><content type="html" xml:base="http://localhost:4000/2015/03/20/install-aria2-on-my-cloud-ex2.html"><![CDATA[<h3 id="0-前言">0. 前言</h3>

<p>之前一直在使用My Book Live，可以方便地使用自带的Debian系统进行应用扩展。配合最常用的aria2和yaaw，可以方便地进行百度网盘、115网盘、迅雷离线等网络存储的脱机下载。</p>

<p>但由于My Book Live在设计上是单盘不可更换硬盘的结构，所以存储满了之后想更换一台扩展性更好的NAS，使用习惯的原因促使我购买了My Book Live的后续产品My Cloud EX2。但没想到My Cloud EX2更换了内部的软件系统，底层的Linux操作系统不再基于Debian，而是一个没有包管理器的自行定制内核，shell使用了busybox进行代替。想要直接安装软件就困难了许多。</p>

<h3 id="1-前期准备">1. 前期准备</h3>

<p>首先是需要将原来My Book Live的数据备份出来，最快的办法是使用暴力将其拆开，然后将硬盘挂载到主板的SATA接口上进行数据对拷。这样多出来的数据盘还可以继续利用。</p>

<p>拆机的攻略可以参照：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">http://bbs.feng.com/read-htm-tid-5609125.html</code></pre></figure>

<p>另外，拆机完成，挂载硬盘到SATA接口上以后，Linux操作系统（比如Ubuntu）是不能直接识别大分区的，需要进行如下操作：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nb">sudo </span>apt-get <span class="nb">install </span>fuseext2 parted
<span class="nb">sudo </span>parted <span class="nt">-l</span> <span class="c">#找到磁盘标识，如/dev/sdb</span>
<span class="nb">sudo </span>fuseext2 <span class="nt">-o</span> allow_other <span class="nt">-o</span> ro <span class="nt">-o</span> sync_read /dev/sdb4 /mnt/</code></pre></figure>

<p>其中allow_other参数很重要，否则会报没有权限的错误。</p>

<p>然后尽情备份即可。</p>

<h3 id="2-制作交叉编译工具链">2. 制作交叉编译工具链</h3>

<p>由于没有包管理器，不可能直接直接安装软件，那么就只能自行使用交叉编译工具进行源码编译。</p>

<p>首先看一下系统的芯片类型：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="c"># cat /proc/cpuinfo</span>
Processor       : Marvell PJ4Bv7 Processor rev 1 <span class="o">(</span>v7l<span class="o">)</span>
BogoMIPS        : 1196.85
Features        : swp half thumb fastmult vfp edsp vfpv3 vfpv3d16 tls 
CPU implementer : 0x56
CPU architecture: 7
CPU variant     : 0x1
CPU part        : 0x581
CPU revision    : 1

Hardware        : Marvell Armada-370
Revision        : 0000
Serial          : 0000000000000000</code></pre></figure>

<p>芯片类型是Marvell Armada-370，也是定制的ARM芯片，那么可以使用crosstool-ng来进行交叉编译器构建。</p>

<p>首先在宿主机（Ubuntu 14.04 LTS）上面从源码编译安装crosstool-ng，下载地址：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">http://crosstool-ng.org/download/crosstool-ng/</code></pre></figure>

<p>在编译安装crosstool-ng交叉工具之前，要安装与crosstool-ng工具相依赖的包文件：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="c"># apt-get install gcc g++ gdb libncurses5-dev bison flex texinfo autoconf automake libtool patch gcj cvs cvsd gawk pkg-config</span></code></pre></figure>

<p>安装好以上依赖的包文件后，就可以编译安装crosstool-ng交叉编译工具了，在编译crosstool-ng交叉编译工具之前，要先配置crosstool-ng交叉编译工具的安装路径：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">./configure <span class="nt">--prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">PATH</span><span class="k">}</span></code></pre></figure>

<p>配置好安装路径后就要编译安装了：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">make
make <span class="nb">install</span></code></pre></figure>

<p>安装好crosstool-ng交叉编译工具后，就要用该工具构建自己的交叉编译链，构建自己的交叉编译工具链之前，要建立自己的工作目录，还有对应的源码文件，然后拷贝默认配置文件到工作目录，进入工作目录后：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nb">cp</span> ../crosstool-ng-1.9.3/samples/arm-unknown-linux-gnueabi /<span class="k">*</span> ./   （以1.9.3为例）</code></pre></figure>

<p>修改文件名：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nb">mv </span>crosstool.config .config</code></pre></figure>

<p>进入menuconfig，开始修改配置：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">../crosstool-ng-1.9.3_install/bin/ct-ng menuconfig</code></pre></figure>

<p>编译选项需要注意的选项如下：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">Paths and misc options  <span class="nt">---</span><span class="o">&gt;</span>Local tarballs directory  
  <span class="o">(</span>/work/tools/Armada-370/crosstool-ng/src<span class="o">)</span> Local tarballs directory   保存源码包路径
Paths and misc options  <span class="nt">---</span><span class="o">&gt;</span>Prefix directory   
  <span class="o">(</span>/work/tools/Armada-370/x-tools/<span class="k">${</span><span class="nv">CT_TARGET</span><span class="k">}</span><span class="o">)</span> Prefix directory  交叉编译器的安装路径
Target options <span class="nt">---</span><span class="o">&gt;</span>Architecture level  
Target options <span class="nt">---</span><span class="o">&gt;</span>Emit assembly <span class="k">for </span>CPU</code></pre></figure>

<p>上面两个根据实际目标板来填写。每一项都可以进去看看，写的都很明确。</p>

<p>这里还有个问题，就是源码包的版本在配置选项中没有的情况，可以通过打开工作目录下的vim .config文件手动修改。</p>

<p>配置好路径和工具的各个版本后，直接运行：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">../crosstool_install/bin/ct-ng build</code></pre></figure>

<p>进行build前面的配置。最后就是漫长的等待（中间需要下载源码），等待之后，自己的交叉编译工具链就完成了。</p>

<p>此外，其实群晖的某个NAS也使用了Armada-370这个芯片进行产品定制，且放出了开发工具包，可以直接下载来使用：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">http://sourceforge.net/projects/dsgpl/files/DSM%204.3%20Tool%20Chains/Marvell%20armada%20370%20Linux%203.2.40/</code></pre></figure>

<p>但是<strong>需要注意</strong>，这个现成的工具包gcc编译器版本是4.6，并不支持包含c++11特性的代码编译。后续文章讲到使用NAS来构建PS3镜像流文件服务器的时候，就必须要使用自行构建的工具链。</p>

<h3 id="3-编译aria2c">3. 编译aria2c</h3>

<p>现在交叉编译器到手，就可以来直接编译aria2c了，能够进行脱机下载功能的aria2c使用到的第三方包包括c-ares、expat和zlib。</p>

<p>为了自动下载源码和编译，我编写了一个shell脚本来完成：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="c">#!/bin/sh</span>

<span class="nv">CWD</span><span class="o">=</span><span class="si">$(</span><span class="nb">pwd</span><span class="si">)</span>
<span class="nv">NJOB</span><span class="o">=</span>4

<span class="c"># Local folder where we install built binaries and libraries.</span>
<span class="nv">LOCAL_DIR</span><span class="o">=</span><span class="si">$(</span><span class="nb">readlink</span> <span class="nt">-f</span> ./local<span class="si">)</span>
<span class="nb">mkdir</span> <span class="nt">-p</span> <span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span>

<span class="c"># Cross-compiler tools</span>
<span class="nv">TOOL_BIN_DIR</span><span class="o">=</span>/opt/arm-marvell-linux-gnueabi/bin
<span class="nv">TOOL_CC</span><span class="o">=</span><span class="k">${</span><span class="nv">TOOL_BIN_DIR</span><span class="k">}</span>/arm-marvell-linux-gnueabi-gcc
<span class="nv">TOOL_CXX</span><span class="o">=</span><span class="k">${</span><span class="nv">TOOL_BIN_DIR</span><span class="k">}</span>/arm-marvell-linux-gnueabi-g++

<span class="nv">PATH</span><span class="o">=</span><span class="k">${</span><span class="nv">TOOL_BIN_DIR</span><span class="k">}</span>:<span class="nv">$PATH</span>

<span class="c"># zlib</span>
<span class="nb">rm</span> <span class="nt">-rf</span>  zlib<span class="k">*</span>
wget http://zlib.net/zlib-1.2.8.tar.gz ./
<span class="nb">tar </span>xzf zlib<span class="k">*</span>.tar.gz
<span class="nb">cd </span>zlib<span class="k">*</span>/
<span class="nv">prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span> <span class="nv">CC</span><span class="o">=</span><span class="k">${</span><span class="nv">TOOL_CC</span><span class="k">}</span> <span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-O4"</span> ./configure <span class="nt">--static</span>
make <span class="nt">-j</span><span class="k">${</span><span class="nv">NJOB</span><span class="k">}</span>
make <span class="nb">install

cd</span> <span class="k">${</span><span class="nv">CWD</span><span class="k">}</span>

<span class="c"># expat</span>
<span class="nb">rm</span> <span class="nt">-rf</span> expat<span class="k">*</span>
wget http://downloads.sourceforge.net/expat/2.1.0/expat-2.1.0.tar.gz ./
<span class="nb">tar </span>xzf expat<span class="k">*</span>.tar.gz
<span class="nb">cd </span>expat<span class="k">*</span>/
./configure <span class="se">\</span>
    <span class="nt">--host</span><span class="o">=</span>arm-marvell-linux-gnueabi <span class="se">\</span>
    <span class="nt">--build</span><span class="o">=</span>i686-linux-gnu <span class="se">\</span>
    <span class="nt">--enable-shared</span><span class="o">=</span>no <span class="se">\</span>
    <span class="nt">--enable-static</span><span class="o">=</span><span class="nb">yes</span> <span class="se">\</span>
    <span class="nt">--prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span>
make <span class="nt">-j</span><span class="k">${</span><span class="nv">NJOB</span><span class="k">}</span>
make <span class="nb">install

cd</span> <span class="k">${</span><span class="nv">CWD</span><span class="k">}</span>

<span class="c"># c-ares</span>
<span class="nb">rm</span> <span class="nt">-rf</span> c-ares<span class="k">*</span>
wget http://c-ares.haxx.se/download/c-ares-1.10.0.tar.gz ./
<span class="nb">tar </span>xzf c-ares<span class="k">*</span>.tar.gz
<span class="nb">cd </span>c-ares<span class="k">*</span>/
./configure <span class="se">\</span>
    <span class="nt">--host</span><span class="o">=</span>arm-marvell-linux-gnueabi <span class="se">\</span>
    <span class="nt">--build</span><span class="o">=</span>i686-linux-gnu <span class="se">\</span>
    <span class="nt">--enable-shared</span><span class="o">=</span>no <span class="se">\</span>
    <span class="nt">--enable-static</span><span class="o">=</span><span class="nb">yes</span> <span class="se">\</span>
    <span class="nt">--prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span>
make <span class="nt">-j</span><span class="k">${</span><span class="nv">NJOB</span><span class="k">}</span>
make <span class="nb">install

cd</span> <span class="k">${</span><span class="nv">CWD</span><span class="k">}</span>

<span class="c"># aria2</span>
<span class="nb">rm</span> <span class="nt">-rf</span> aria2<span class="k">*</span>
wget http://downloads.sourceforge.net/aria2/aria2-1.18.10.tar.xz ./
<span class="nb">tar </span>xJf aria2<span class="k">*</span>.tar.xz
<span class="nb">cd </span>aria2<span class="k">*</span>/
./configure <span class="se">\</span>
    <span class="nt">--host</span><span class="o">=</span>arm-marvell-linux-gnueabi <span class="se">\</span>
    <span class="nt">--build</span><span class="o">=</span>i686-linux-gnu <span class="se">\</span>
    <span class="nt">--disable-nls</span> <span class="se">\</span>
    <span class="nt">--disable-ssl</span> <span class="se">\</span>
    <span class="nt">--disable-epoll</span> <span class="se">\</span>
    <span class="nt">--without-gnutls</span> <span class="se">\</span>
    <span class="nt">--without-openssl</span> <span class="se">\</span>
    <span class="nt">--without-sqlite3</span> <span class="se">\</span>
    <span class="nt">--without-libxml2</span> <span class="se">\</span>
    <span class="nt">--with-libexpat</span> <span class="nt">--with-libexpat-prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span> <span class="se">\</span>
    <span class="nt">--with-libcares</span> <span class="nt">--with-libcares-prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span> <span class="se">\</span>
    <span class="nt">--with-libz</span> <span class="nt">--with-libz-prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span> <span class="se">\</span>
    <span class="nt">--prefix</span><span class="o">=</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span> <span class="se">\</span>
    <span class="nt">--enable-static</span><span class="o">=</span><span class="nb">yes</span> <span class="se">\</span>
    <span class="nv">CXXFLAGS</span><span class="o">=</span><span class="s2">"-Os -g"</span> <span class="se">\</span>
    <span class="nv">CFLAGS</span><span class="o">=</span><span class="s2">"-Os -g"</span> <span class="se">\</span>
    <span class="nv">LDFLAGS</span><span class="o">=</span><span class="s2">"-L</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span><span class="s2">/lib"</span> <span class="se">\</span>
    <span class="nv">PKG_CONFIG_LIBDIR</span><span class="o">=</span><span class="s2">"</span><span class="k">${</span><span class="nv">LOCAL_DIR</span><span class="k">}</span><span class="s2">/lib/pkgconfig"</span> <span class="se">\</span>
    <span class="nv">ARIA2_STATIC</span><span class="o">=</span><span class="s2">"yes"</span>
make <span class="nt">-j</span><span class="k">${</span><span class="nv">NJOB</span><span class="k">}</span>
make <span class="nb">install</span></code></pre></figure>

<p>上面的shell脚本可以直接自动从网络上下载截止博文发出的最新版本的aria2及其依赖的源码，并进行编译（全部使用静态编译，避免运行环境找不到库的情况出现）。</p>

<p>需要注意的是，TOOL_BIN_DIR是交叉工具链的安装目录，需要按照实际情况进行修改。</p>

<p><strong><em>另外这个脚本应该在一个干净的目录进行执行。</em></strong></p>

<h3 id="4-安装aria2c和yaaw">4. 安装aria2c和yaaw</h3>

<p>将编译得到的aria2上传到My Cloud EX2的目录：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">/mnt/HD/HD_a2/Nas_Prog</code></pre></figure>

<p>并建立一个配置文件，内容如下：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">daemon</span><span class="o">=</span><span class="nb">true</span>  <span class="c">#以daemon方式启动</span>
<span class="nb">dir</span><span class="o">=</span>/mnt/HD/HD_a2/Private/Download  <span class="c">#下载目录</span>
disable-ipv6<span class="o">=</span><span class="nb">true</span> <span class="c">#禁用IPv6</span>
enable-rpc<span class="o">=</span><span class="nb">true</span> <span class="c">#启用RPC，对于yaaw的配合使用非常重要</span>
rpc-allow-origin-all<span class="o">=</span><span class="nb">true 
</span>rpc-listen-all<span class="o">=</span><span class="nb">true
</span>rpc-listen-port<span class="o">=</span>6800 <span class="c">#监听端口</span>
<span class="k">continue</span><span class="o">=</span><span class="nb">true</span> <span class="c">#开启断点续传</span>
input-file<span class="o">=</span>/mnt/HD/HD_a2/Nas_Prog/aria2/session/aria2.session <span class="c">#session保存地址，用于记录任务信息</span>
save-session<span class="o">=</span>/mnt/HD/HD_a2/Nas_Prog/aria2/session/aria2.session
file-allocation<span class="o">=</span>falloc <span class="c">#文件分配方式</span>
max-concurrent-downloads<span class="o">=</span>1 <span class="c">#最大并行下载任务数量</span>
max-connection-per-server<span class="o">=</span>5 <span class="c">#每个服务器的并发连接数</span>
min-split-size<span class="o">=</span>10M <span class="c">#最大文件分割大小</span>
<span class="nb">split</span><span class="o">=</span>10 <span class="c">#文件分割块数</span>
<span class="nv">log</span><span class="o">=</span>/mnt/HD/HD_a2/Nas_Prog/aria2/log/aria2.log <span class="c">#日志路径</span>
log-level<span class="o">=</span>warn <span class="c">#日志级别</span></code></pre></figure>

<p>然后用命令启动：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nb">cd</span> /mnt/HD/HD_a2/Nas_Prog/aria2
./aria2c <span class="nt">--conf-path</span><span class="o">=</span>./conf/aria2.conf</code></pre></figure>

<p>然后安装yaaw，下载地址：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">https://github.com/binux/yaaw</code></pre></figure>

<p>解压后也放到/mnt/HD/HD_a2/Nas_Prog目录，然后建立一个指向web服务器根目录的软连接：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nb">ln</span> <span class="nt">-s</span> /mnt/HD/HD_a2/Nas_Prog/yaaw /var/www/yaaw</code></pre></figure>

<p>这样就可以直接从NAS的IP访问到yaaw了。</p>

<h3 id="5-后续配置">5. 后续配置</h3>

<p>使用上，可以配合百度云盘、115网盘的chrome插件进行。</p>

<p>Chrome Web Store的地址：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">115网盘： https://chrome.google.com/webstore/detail/115exporter/ojafklbojgenkohhdgdjeaepnbjffdjf

百度网盘： https://chrome.google.com/webstore/detail/baiduexporter/mjaenbjdjmgolhoafkohbhhbaiedbkno</code></pre></figure>

<p>配置上，将json-rpc的地址指向【NAS的IP:6800】即可（默认情况），然后下载的时候选中需要下载的文件，按“导出到RPC”。</p>

<p>此外，【http://NAS的IP/yaaw】这个地址可以查看aria2的运行情况，同时也可以使用Web的方式来使用Aria2，当然下载都是My Cloud EX2的任务了。</p>

<p>-EOF-</p>]]></content><author><name></name></author><category term="嵌入式" /><category term="kernel" /><category term="my cloud" /><category term="yaaw" /><category term="aria2" /><summary type="html"><![CDATA[在My Cloud EX2上安装aria2和yaaw]]></summary></entry><entry><title type="html">Windows 8/8.1 上的MotionJoy和DS3配置</title><link href="http://localhost:4000/2015/02/20/motionjoy-and-ds3-config-on-windows-8.html" rel="alternate" type="text/html" title="Windows 8/8.1 上的MotionJoy和DS3配置" /><published>2015-02-20T00:00:00+08:00</published><updated>2015-02-20T00:00:00+08:00</updated><id>http://localhost:4000/2015/02/20/motionjoy-and-ds3-config-on-windows-8</id><content type="html" xml:base="http://localhost:4000/2015/02/20/motionjoy-and-ds3-config-on-windows-8.html"><![CDATA[<p>最近更新了Windows 8.1系统，原来使用正常的MotionJoy没法正常安装了，google了一圈解决办法，记录在这里。<br />
首先还是要到MotionJoy的官网上去下载最新版本的安装包，然后安装：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">http://motioninjoy.en.uptodown.com/  </code></pre></figure>

<p>由于MotionJoy的官网已经被功夫网和谐，而这个广告巨多的软件需要运行时联网，所以还需要到下面的链接去下载一个本地支持的补丁：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">http://bbs.3dmgame.com/forum.php?mod<span class="o">=</span>attachment&amp;aid<span class="o">=</span>MzA4MjMyNXw1MTkxNjYxYnwxNDMwNDc1NjMxfDB8NDQ3OTYwMw%3D%3D  </code></pre></figure>

<p>将解压得到的文件覆盖到MotionJoy安装目录的DS3子目录下。<br />
接下来，由于Windows 8.1对于驱动签名采取了比较严格的验证机制，直接安装DS3驱动是会失败的，所以需要使用管理员权限的命令行提示符执行以下命令将验证关闭：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">bcdedit <span class="nt">-set</span> loadoptions DISABLE_INTEGRITY_CHECKS  
bcdedit <span class="nt">-set</span> TESTSIGNING ON  
bcdedit /set testsigning on  </code></pre></figure>

<p>运行完毕后重新启动计算机。<br />
然后插入DS3手柄，进入MotionJoy安装目录的DS3子目录，以管理员权限运行DS3_Tool_Local.exe，点击Driver Manager，选中识别到的手柄，选择Install All即可安装驱动。<br />
安装完毕后点击Profiles，可以看到手柄已经被成功识别。</p>

<p>最后把验证再重新开启：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">bcdedit /set testsigning off  
bcdedit <span class="nt">-set</span> TESTSIGNING OFF  </code></pre></figure>]]></content><author><name></name></author><category term="motionjoy" /><category term="ps3" /><category term="ds3" /><summary type="html"><![CDATA[Windows 8/8.1 上的MotionJoy和DS3配置]]></summary></entry><entry><title type="html">cubietruck安装Cubieez/Lubuntu笔记</title><link href="http://localhost:4000/2015/01/01/install-cubieez-lubuntu-on-cubietruck.html" rel="alternate" type="text/html" title="cubietruck安装Cubieez/Lubuntu笔记" /><published>2015-01-01T00:00:00+08:00</published><updated>2015-01-01T00:00:00+08:00</updated><id>http://localhost:4000/2015/01/01/install-cubieez-lubuntu-on-cubietruck</id><content type="html" xml:base="http://localhost:4000/2015/01/01/install-cubieez-lubuntu-on-cubietruck.html"><![CDATA[<p>工具：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">PhoneixSuite<span class="o">(</span>Windows<span class="o">)</span>
SecureCRT</code></pre></figure>

<p>固件下载链接：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">http://dl.cubieboard.org/software/a20-cubietruck/</code></pre></figure>

<p>按照需求下载对应的固件，解压后使用PhoneixSuite刷入cubietruck即可。</p>

<p>罗技无线键鼠没法使用的解决办法：</p>

<p>因为内核中的驱动支持HIDRAW默认是关闭的，重新编译一次内核即可。</p>

<p>烧录好的系统，ssh登录进去，到/proc/目录下找到config.gz，是当前内核的配置文件，拷贝出来到内核源码目录，解压重命名为.config。这么做是为了最大兼容当前运行内核。</p>

<p>内核源码的github地址：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">https://github.com/linux-sunxi/linux-sunxi</code></pre></figure>

<p>或者可以去固件目录下载。</p>

<p>当前交叉编译系统的版本必须是ubuntu 12.04 lts，保证编译器版本为gcc 4.6，高版本编译的内核无法在开发板上运行。</p>

<p>交叉编译环境准备：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nb">sudo </span>apt-get <span class="nb">install </span>build-essential u-boot-tools uboot-mkimage
<span class="nb">sudo </span>apt-get <span class="nb">install </span>gcc-arm-linux-gnueabihf gcc-arm-linux-gnueabi
<span class="nb">sudo </span>apt-get <span class="nb">install </span>libusb-1.0-0 libusb-1.0-0-dev git wget fakeroot kernel-package zlib1g-dev
<span class="nb">sudo </span>apt-get <span class="nb">install </span>libncurses5-dev</code></pre></figure>

<p>其他包按照提示安装即可。</p>

<p>编译选项打开HIDRAW：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">make <span class="nv">ARCH</span><span class="o">=</span>arm menuconfig</code></pre></figure>

<p>编译：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">make <span class="nt">-j4</span> <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">CROSS_COMPILE</span><span class="o">=</span>arm-none-linux-gnueabi- uImage modules</code></pre></figure>

<p>安装modules：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">make <span class="nv">STRIP</span><span class="o">=</span>arm-none-linux-gnueabi-strip <span class="nv">INSTALL_MOD_PATH</span><span class="o">=</span>output <span class="nv">ARCH</span><span class="o">=</span>arm <span class="nv">INSTALL_MOD_STRIP</span><span class="o">=</span>1 modules_install</code></pre></figure>

<p>然后把output目录下的modules替换到开发板的/lib/modules下，/arch/arm/boot/uImage替换到开发板/boot目录下，内核就升级完成了，重启即可。</p>

<p>-EOF-</p>]]></content><author><name></name></author><category term="嵌入式" /><category term="ubuntu" /><category term="cubietruck" /><category term="cubieez" /><summary type="html"><![CDATA[cubietruck安装Cubieez/Lubuntu笔记]]></summary></entry><entry><title type="html">Felix入门与实践</title><link href="http://localhost:4000/2013/01/30/felix-tutorial.html" rel="alternate" type="text/html" title="Felix入门与实践" /><published>2013-01-30T00:00:00+08:00</published><updated>2013-01-30T00:00:00+08:00</updated><id>http://localhost:4000/2013/01/30/felix-tutorial</id><content type="html" xml:base="http://localhost:4000/2013/01/30/felix-tutorial.html"><![CDATA[<p>首先，我假设你已经了解OSGi相关的一些概念，如果没有，可以看看官方的文档。</p>

<p>我们从创建一个监听OSGi Service事件的bundle开始。这个小例子并不会包含太多的东西，只是打印出注册以及未注册的Service的详细信息而已。下一篇我才会开始介绍实现了Service的bundle，这次只是通过一个范例来加深对于创建bundle基础知识的理解。</p>

<p>OSGi框架通过与bundle唯一对应的BundleContext来访问一个bundle，而得到BundleContext必须实现BundleActivator接口。这个接口有两个方法，start()和stop()。当bundle的被start或者stop的时候，BundleContext将作为参数传入这两个方法，然后这两个方法才会被调用。下面的源代码是一个bundle，当然它实现了BundleContext接口，同时这个bundle添加了自身作为Service事件的监听器。</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="nn">tutorial.example1</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.osgi.framework.BundleActivator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.osgi.framework.BundleContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.osgi.framework.ServiceListener</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.osgi.framework.ServiceEvent</span><span class="o">;</span>

<span class="cm">/**
 * This class implements a simple bundle that utilizes the OSGi
 * framework's event mechanism to listen for service events. Upon
 * receiving a service event, it prints out the event's details.
**/</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Activator</span> <span class="kd">implements</span> <span class="nc">BundleActivator</span><span class="o">,</span> <span class="nc">ServiceListener</span>
<span class="o">{</span>
    <span class="cm">/**
     * Implements BundleActivator.start(). Prints
     * a message and adds itself to the bundle context as a service
     * listener.
     * @param context the framework context for the bundle.
    **/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">start</span><span class="o">(</span><span class="nc">BundleContext</span> <span class="n">context</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Starting to listen for service events."</span><span class="o">);</span>
        <span class="n">context</span><span class="o">.</span><span class="na">addServiceListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Implements BundleActivator.stop(). Prints
     * a message and removes itself from the bundle context as a
     * service listener.
     * @param context the framework context for the bundle.
    **/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">stop</span><span class="o">(</span><span class="nc">BundleContext</span> <span class="n">context</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="n">context</span><span class="o">.</span><span class="na">removeServiceListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Stopped listening for service events."</span><span class="o">);</span>

        <span class="c1">// Note: It is not required that we remove the listener here,</span>
        <span class="c1">// since the framework will do it automatically anyway.</span>
    <span class="o">}</span>

    <span class="cm">/**
     * Implements ServiceListener.serviceChanged().
     * Prints the details of any service event from the framework.
     * @param event the fired service event.
    **/</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">serviceChanged</span><span class="o">(</span><span class="nc">ServiceEvent</span> <span class="n">event</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="nc">String</span><span class="o">[]</span> <span class="n">objectClass</span> <span class="o">=</span> <span class="o">(</span><span class="nc">String</span><span class="o">[])</span>
            <span class="n">event</span><span class="o">.</span><span class="na">getServiceReference</span><span class="o">().</span><span class="na">getProperty</span><span class="o">(</span><span class="s">"objectClass"</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getType</span><span class="o">()</span> <span class="o">==</span> <span class="nc">ServiceEvent</span><span class="o">.</span><span class="na">REGISTERED</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                <span class="s">"Ex1: Service of type "</span> <span class="o">+</span> <span class="n">objectClass</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">" registered."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getType</span><span class="o">()</span> <span class="o">==</span> <span class="nc">ServiceEvent</span><span class="o">.</span><span class="na">UNREGISTERING</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                <span class="s">"Ex1: Service of type "</span> <span class="o">+</span> <span class="n">objectClass</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">" unregistered."</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getType</span><span class="o">()</span> <span class="o">==</span> <span class="nc">ServiceEvent</span><span class="o">.</span><span class="na">MODIFIED</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span>
                <span class="s">"Ex1: Service of type "</span> <span class="o">+</span> <span class="n">objectClass</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="s">" modified."</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>完成bundle的Java代码之后还不够，我们还需要定义一个包含了meta-data信息的manifest文件，这样OSGi框架才能“操作”这个bundle。manifest文件要和编译好的Java Class打包成一个Jar，而这个Jar包实际上就是一个bundle。我们接下来创建一个名为manifest.mf的文件，内容如下：</p>

<figure class="highlight"><pre><code class="language-html" data-lang="html">Bundle-Name: Service listener example
Bundle-Description: A bundle that displays messages at startup and when service events occur
Bundle-Vendor: Apache Felix
Bundle-Version: 1.0.0
Bundle-Activator: tutorial.example1.Activator
Import-Package: org.osgi.framework</code></pre></figure>

<p>上面的meta-data信息大部分只是为了维护方便，实际上只有Bundle-Activator属性以及Import-Package属性是OSGi框架必须的。Bundle-Activator属性为框架指明了实现了BundleActivator接口的类。当OSGi框架start某个bundle的时候，将创建一个该属性指定的类的实例，同时调用该实例的start()方法；同样框架stop该bundle的时候，实例的stop()方法将被调用。Import-Package属性指定了这个bundle所依赖的外部类。所有的bundle必须导入org.osgi.framework这个类，因为它包含了OSGi类的核心定义。所有的包依赖关系都会由OSGi框架来验证以及处理。（注意，manifest文件最后一行之后必须有一个回车符，否则最后一行的内容将会被框架忽略。）</p>

<p>然后就可以开始编译源代码了，我们需要把felix.jar添加到classpath中（Felix的bin目录中可以找到这个jar包），然后在命令行中运行：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">javac <span class="nt">-d</span> c:<span class="se">\c</span>lasses <span class="k">*</span>.java</code></pre></figure>

<p>上面的命令将会编译classes目录下所有的源代码，并将class二进制字节码输出到指定的子文件夹tutorial\example1中。编译完成之后，就可以把class文件和之前写好的bundle的manifest文件打包成jar。接着在命令行中运行：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">jar cfm example1.jar manifest.mf <span class="nt">-C</span> c:<span class="se">\c</span>lasses tutorial<span class="se">\e</span>xample1</code></pre></figure>

<p>一个打包好的bundle就到手了，用Felix的Shell就可以安装并运行这个bundle，比如：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">start file:/c:/tutorial/example1.jar </code></pre></figure>

<p>上面的命令会自动安装并start这个bundle。当然我们也可以手动安装并且运行。Felix的Shell有install和start两个命令，分别运行一下就OK。另外stop命令可以stop指定的bundle，而shutdown则是关闭整个Felix环境。</p>

<p>-EOF-</p>]]></content><author><name></name></author><category term="felix" /><category term="OSGi" /><category term="java" /><category term="service" /><summary type="html"><![CDATA[Felix入门与实践]]></summary></entry><entry><title type="html">Windows下编译OpenJDK7 笔记</title><link href="http://localhost:4000/2012/11/19/compile-jdk7-under-windows.html" rel="alternate" type="text/html" title="Windows下编译OpenJDK7 笔记" /><published>2012-11-19T00:00:00+08:00</published><updated>2012-11-19T00:00:00+08:00</updated><id>http://localhost:4000/2012/11/19/compile-jdk7-under-windows</id><content type="html" xml:base="http://localhost:4000/2012/11/19/compile-jdk7-under-windows.html"><![CDATA[<h3 id="0-系统需求">0. 系统需求</h3>

<p>Windows XP SP3 / Windows 7 （强烈推荐用英文版系统进行构建，原因后详）</p>

<h3 id="1-所需软件">1. 所需软件</h3>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">Cygwin

Sun JDK 1.6 u14以上

Microsoft DirecxX SDK

Microsoft Visual Studio C++ 2010 （正式版或者Express版均可）

Apache Ant 1.7.1以上

Freetype-2.3.5-1

openjdk-7-fcs-src-b147-27_jun_2011.zip

Vim（可选，推荐编辑器）</code></pre></figure>

<h3 id="2构建步骤">2.构建步骤</h3>

<p><strong><em>以下涉及安装软件的步骤，都建议将软件安装到没有空格非中文的路径，且安装的目录名精简一些。</em></strong></p>

<p>(1) 首先安装Cygwin，所需的包如下所示：</p>

<table rules="groups">
  <thead>
    <tr>
      <th style="text-align: left">文件名</th>
      <th style="text-align: center">分类</th>
      <th style="text-align: right">包</th>
      <th style="text-align: right">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">ar.exe</td>
      <td style="text-align: center">Devel</td>
      <td style="text-align: right">binutils</td>
      <td style="text-align: right">The GNU assembler, linker and binary utilities</td>
    </tr>
    <tr>
      <td style="text-align: left">make.exe</td>
      <td style="text-align: center">Devel</td>
      <td style="text-align: right">make</td>
      <td style="text-align: right">The GNU version of the ‘make’ utility built for CYGWIN</td>
    </tr>
    <tr>
      <td style="text-align: left">m4.exe</td>
      <td style="text-align: center">Interpreters</td>
      <td style="text-align: right">m4</td>
      <td style="text-align: right">GNU implementation of the traditional Unix macro processor</td>
    </tr>
    <tr>
      <td style="text-align: left">cpio.exe</td>
      <td style="text-align: center">Utils</td>
      <td style="text-align: right">cpio</td>
      <td style="text-align: right">A program to manage archives of files</td>
    </tr>
    <tr>
      <td style="text-align: left">gawk.exe</td>
      <td style="text-align: center">Base</td>
      <td style="text-align: right">awk</td>
      <td style="text-align: right">Pattern-directed scanning and processing language</td>
    </tr>
    <tr>
      <td style="text-align: left">file.exe</td>
      <td style="text-align: center">Utils</td>
      <td style="text-align: right">file</td>
      <td style="text-align: right">Determines file type using ‘magic’ numbers</td>
    </tr>
    <tr>
      <td style="text-align: left">zip.exe</td>
      <td style="text-align: center">Archive</td>
      <td style="text-align: right">zip</td>
      <td style="text-align: right">Package and compress (archive) files</td>
    </tr>
    <tr>
      <td style="text-align: left">unzip.exe</td>
      <td style="text-align: center">Archive</td>
      <td style="text-align: right">unzip</td>
      <td style="text-align: right">Extract compressed files in a ZIP archive</td>
    </tr>
    <tr>
      <td style="text-align: left">free.exe</td>
      <td style="text-align: center">System</td>
      <td style="text-align: right">procps</td>
      <td style="text-align: right">Display amount of free and used memory in the system</td>
    </tr>
  </tbody>
</table>

<p>需要注意的是，安装的make.exe为3.82版，导致编译不能成功，需要从cygwin网站上下载3.81版本并覆盖到bin目录。也可以下载源码之后自己编译一个（需要gcc包）。最后将cygwin的bin目录添加到PATH环境变量。</p>

<p>(2) 安装JDK6，版本需要u14以上（官方文档中称作Bootrap JDK），我采用的是u31版本。建立ALT_BOOTDIR和ALT_JDK_IMPORT_PATH环境变量，指向JDK的目录。注意不要设置JAVA_HOME和CLASSPATH环境变量。</p>

<p>(3) 安装Apache Ant，版本1.7.1以上，我采用的是1.8.2。建立ANT_HOME环境变量。</p>

<p>(4) 安装Freetype-2.3.5-1，建立ALT_FREETYPE_LIB_PATH 和ALT_FREETYPE_HEADERS_PATH环境变量，分别指向lib目录和include目录。将bin目录下的freetype6.dll和zlib1.dll复制到lib目录下。</p>

<p>(5) 安装DirectX SDK。强烈建议此步在安装Visual Stuido 2010 (Express)之前进行，否则有可能DirectX SDK无法正常安装成功。建立ALT_DXSDK_PATH环境变量，指向安装目录。</p>

<p>(6) 安装Microsoft Visual Studio C++ 2010 ，我采用的是Express版本（免费）。安装过程中会自动安装Windows SDK，且不能指定路径，在C:\Program Files\下。建立ALT_COMPILER_PATH 环境变量，指向VC++的bin目录。同时用以下命令将Windows SDK的目录转换为short路径（需要安装cygwin）：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">Cygpath –s –m “C:<span class="se">\P</span>rogram Files<span class="se">\M</span>icrosoft SDKs<span class="se">\W</span>indows<span class="se">\v</span>7.0A”</code></pre></figure>

<p>之后建立WINDOWSSDKDIR 环境变量，指向该short路径。</p>

<p>将WINDOWSSDKDIR 下的lib目录和VC++下的lib目录添加到LIB环境变量。</p>

<p>将WINDOWSSDKDIR 下的include目录和VC++下的include目录添加到INCLUDE环境变量。</p>

<p>去下载一个msvcr100.dll，并建立ALT_MSVCRNN_DLL_PATH 环境变量指向该文件所在的目录。如果你安装了Visual Studio C++ 2010，那么在你的系统中应该能找到这个文件，但是我用系统中自带的这个文件编译出的JDK不能正常运行，用下载的替换之后才可以。</p>

<p>(7) 解压openjdk-7-fcs-src-b147-27_jun_2011.zip，下载jaxp-1_4_5-unittests.zip、jaxp145_01.zip、jdk7-jaf-2010_08_19.zip、jdk7-jaxws2_2_4-b03-2011_05_27.zip四个文件放在openjdk\java\devtools\share\jdk7-drops目录下。并建立ALT_DROPS_DIR 环境变量指向该目录。</p>

<p>(8) 完善并检查环境变量，我写了一个批处理来进行环境变量设置：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">SET <span class="nv">VSINSTALLDIR</span><span class="o">=</span>C:/PROGRA~2/MICROS~1.0
SET <span class="nv">WINDOWSSDKDIR</span><span class="o">=</span>D:/jdkBuild/sdk
SET <span class="nv">ALT_BOOTDIR</span><span class="o">=</span>D:/jdkBuild/JDK16~1.0_X
SET <span class="nv">ALT_JDK_IMPORT_PATH</span><span class="o">=</span>D:/jdkBuild/JDK16~1.0_X
SET <span class="nv">ANT_HOME</span><span class="o">=</span>D:/jdkBuild/APACHE~1.4
SET <span class="nv">ALT_MSVCRNN_DLL_PATH</span><span class="o">=</span>D:/jdkBuild/msvcr100
SET <span class="nv">ALT_DXSDK_PATH</span><span class="o">=</span>D:/jdkBuild/msdxsdk
SET <span class="nv">ALT_FREETYPE_HEADERS_PATH</span><span class="o">=</span>D:/jdkBuild/freetype/include
SET <span class="nv">ALT_FREETYPE_LIB_PATH</span><span class="o">=</span>D:/jdkBuild/freetype/lib
SET <span class="nv">ALT_COMPILER_PATH</span><span class="o">=</span>%VSINSTALLDIR%/VC/bin/
SET <span class="nv">ALT_DROPS_DIR</span><span class="o">=</span> D:/jdkBuild/openjdk/java/devtools/share/jdk7-drops
SET <span class="nv">PATH</span><span class="o">=</span>%WINDOWSSDKDIR%/Bin/NETFX4~1.0TO<span class="p">;</span>%WINDOWSSDKDIR%/Bin<span class="p">;</span>%VSINSTALLDIR%/VC/bin<span class="p">;</span>%VSINSTALLDIR%/Common7/IDE<span class="p">;</span>E:/cygwin/bin<span class="p">;</span>%PATH%
SET <span class="nv">INCLUDE</span><span class="o">=</span>%VSINSTALLDIR%/VC/INCLUDE<span class="p">;</span>D:/jdkBuild/sdk/INCLUDE
SET <span class="nv">LIB</span><span class="o">=</span>%VSINSTALLDIR%/VC/Lib<span class="p">;</span>D:/jdkBuild/sdk/Lib
SET ALT_CC_VER <span class="o">=</span> 16.00.30319.01
SET ALT_MSC_VER_RAW <span class="o">=</span> 16.00.30319.01</code></pre></figure>

<p>其中带~的路径均为cygpath所转化所得的short路径。</p>

<p>建议路径中的分割符采用斜线（/）而不是反斜线（\），Windows资源管理器的默认显示路径是后者。如果采用反斜线，有可能在编译过程中某些脚本识别不出路径，从而出错。</p>

<p>同时cygwin的bin目录在PATH中的位置应该在系统的System32目录之前（脚本中会用到cygwin的find命令，否则会用windows的find命令导致出错）。而VC++的bin目录应该在cygwin之前（同样的原因，编译需要用到的是VC++中的link.exe）。</p>

<p>(9) 修改文件。</p>

<p><strong>文件： /jdk/make/sun/font/Makefile:</strong>
<strong>第126行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">FREETYPE_LIB <span class="o">=</span><span class="si">$(</span>LIB_LOCATION<span class="si">)</span>/<span class="si">$(</span>LIB_PREFIX<span class="si">)</span>freetype.<span class="si">$(</span>LIBRARY_SUFFIX<span class="si">)</span></code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">FREETYPE_LIB <span class="o">=</span><span class="si">$(</span>LIB_LOCATION<span class="si">)</span>/<span class="si">$(</span>LIB_PREFIX<span class="si">)</span>freetype6.<span class="si">$(</span>LIBRARY_SUFFIX<span class="si">)</span> 
ZLIB1_LIB <span class="o">=</span><span class="si">$(</span>LIB_LOCATION<span class="si">)</span>/<span class="si">$(</span>LIB_PREFIX<span class="si">)</span>zlib1.<span class="si">$(</span>LIBRARY_SUFFIX<span class="si">)</span></code></pre></figure>

<p><strong>第137，138行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="si">$(</span>FREETYPE_LIB<span class="si">)</span>:
 
<span class="si">$(</span>CP<span class="si">)$(</span>FREETYPE_LIB_PATH<span class="si">)</span>/<span class="si">$(</span>LIB_PREFIX<span class="si">)</span>freetype.<span class="si">$(</span>LIBRARY_SUFFIX<span class="si">)</span> <span class="nv">$@</span></code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="si">$(</span>FREETYPE_LIB<span class="si">)</span>: <span class="si">$(</span>ZLIB1_LIB<span class="si">)</span>
 
<span class="si">$(</span>CP<span class="si">)$(</span>FREETYPE_LIB_PATH<span class="si">)</span>/<span class="si">$(</span>LIB_PREFIX<span class="si">)</span>freetype6.<span class="si">$(</span>LIBRARY_SUFFIX<span class="si">)</span> <span class="nv">$@</span>
 
<span class="si">$(</span>install-module-file<span class="si">)</span>
 
<span class="si">$(</span>ZLIB1_LIB<span class="si">)</span>:
 
<span class="si">$(</span>CP<span class="si">)</span> <span class="si">$(</span>FREETYPE_LIB_PATH<span class="si">)</span>/<span class="si">$(</span>LIB_PREFIX<span class="si">)</span>zlib1.<span class="si">$(</span>LIBRARY_SUFFIX<span class="si">)</span><span class="nv">$@</span></code></pre></figure>

<p><strong>文件：jdk/make/tools/freetypecheck/Makefile</strong></p>

<p><strong>第41行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">FREETYPE_DLL <span class="o">=</span><span class="si">$(</span>FREETYPE_LIB_PATH<span class="si">)</span>/freetype.dll</code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">FREETYPE_DLL <span class="o">=</span><span class="si">$(</span>FREETYPE_LIB_PATH<span class="si">)</span>/freetype6.dll
 
ZLIB1_DLL <span class="o">=</span> <span class="si">$(</span>FREETYPE_LIB_PATH<span class="si">)</span>/zlib1.dll</code></pre></figure>

<p><strong>第72行下加入：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="si">$(</span>CP<span class="si">)</span> <span class="si">$(</span>ZLIB1_DLL<span class="si">)</span> <span class="si">$(</span>@D<span class="si">)</span>/</code></pre></figure>

<p><strong>文件：jdk/src/share/classes/sun/font/FontManagerNativeLibrary.java</strong></p>

<p><strong>第59行：</strong></p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">"freetype"</span><span class="o">);</span></code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">"freetype6"</span><span class="o">);</span></code></pre></figure>

<p>OpenJDK的部分java文件注释是中文的。javac却指定了ascii编码方式（添加了参数-encoding ascii）。遇到包含中文的java文件，javac会报错。因此需要将-encoding编译选项去掉。</p>

<p><strong>文件：/corba/make/common/shared/Defs-java.gmk</strong></p>

<p><strong>第133行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">JAVACFLAGS +<span class="o">=</span> <span class="nt">-encoding</span> ascii</code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="c"># JAVACFLAGS  += -encoding ascii</span></code></pre></figure>

<p><strong>第194行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"> 
BOOT_JAVACFLAGS  +<span class="o">=</span> <span class="nt">-encoding</span> ascii <span class="nt">-source</span><span class="si">$(</span>BOOT_SOURCE_LANGUAGE_VERSION<span class="si">)</span> <span class="nt">-target</span> <span class="si">$(</span>BOOT_TARGET_CLASS_VERSION<span class="si">)</span></code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">BOOT_JAVACFLAGS +<span class="o">=</span> <span class="nt">-source</span> <span class="si">$(</span>BOOT_SOURCE_LANGUAGE_VERSION<span class="si">)</span><span class="nt">-target</span> <span class="si">$(</span>BOOT_TARGET_CLASS_VERSION<span class="si">)</span></code></pre></figure>

<p><strong>文件：/jdk/make/common/shared/Defs-java.gmk</strong></p>

<p><strong>第134行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">JAVACFLAGS +<span class="o">=</span> <span class="nt">-encoding</span> ascii</code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"> 
<span class="c"># JAVACFLAGS  += -encoding ascii</span></code></pre></figure>

<p><strong>第212行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">BOOT_JAVACFLAGS  +<span class="o">=</span> <span class="nt">-encoding</span> ascii <span class="nt">-source</span><span class="si">$(</span>BOOT_SOURCE_LANGUAGE_VERSION<span class="si">)</span> <span class="nt">-target</span> <span class="si">$(</span>BOOT_TARGET_CLASS_VERSION<span class="si">)</span></code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">BOOT_JAVACFLAGS +<span class="o">=</span> <span class="nt">-source</span><span class="si">$(</span>BOOT_SOURCE_LANGUAGE_VERSION<span class="si">)</span> <span class="nt">-target</span> <span class="si">$(</span>BOOT_TARGET_CLASS_VERSION<span class="si">)</span></code></pre></figure>

<p><strong>文件：/hotspot/make/windows/makefiles/rules.make</strong></p>

<p><strong>第48行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">JAVAC_FLAGS</span><span class="o">=</span><span class="nt">-g</span> <span class="nt">-encoding</span> ascii</code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">JAVAC_FLAGS</span><span class="o">=</span><span class="nt">-g</span></code></pre></figure>

<p>OpenJDK启用了VC的“将警告视为错误”（warnings as errors）选项。如果链接器生成警告，/WX 将不会生成任何输出文件。</p>

<p><strong>文件：/hotspot/make/windows/makefiles/compile.make</strong></p>

<p><strong>第53行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"><span class="nv">CPP_FLAGS</span><span class="o">=</span>/nologo /W3 /WX</code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh"> 
<span class="nv">CPP_FLAGS</span><span class="o">=</span>/nologo /W3 /WX-</code></pre></figure>

<p><strong>文件：/hotspot/src/share/tools/hsdis/Makefile</strong></p>

<p><strong>第92行：</strong></p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">CFLAGS        +<span class="o">=</span> /nologo /MD /W3 /WX /O2 /Fo<span class="si">$(</span>@:.dll<span class="o">=</span>.obj<span class="si">)</span> /Gi-</code></pre></figure>

<p>改为：</p>

<figure class="highlight"><pre><code class="language-sh" data-lang="sh">CFLAGS        +<span class="o">=</span> /nologo /MD /W3 /WX- /O2 /Fo<span class="si">$(</span>@:.dll<span class="o">=</span>.obj<span class="si">)</span> /Gi-</code></pre></figure>

<p><strong>文件：/hotspot/make/windows/get_msc_ver.sh以及/jdk/make/common/shared/Compiler-msvc.gmk</strong></p>

<p>由于get_msc_ver.sh脚本文件是根据cl.exe的输出信息来判断编译器的版本的，而这个脚本只考虑了输出信息为英文的情况，所以本文开头强烈建议使用英文版的系统以及VS进行编译。如果你使用中文系统，那么有两个选择，一是将系统的区域和语言设置改为英文；二是直接将MSC_VER_RAW和CC_VER两个变量的值写入这两个文件（当然前提是你确保使用的编译器版本正确）。第二种方法我没有尝试成功，最后在虚拟机中安装了英文系统才编译通过。</p>

<p>另外编译过程中如果出现COMPILER_VERSION没有设置的提示，那么可以直接将COMPILER_VERSION = VS2010写入Compiler-msvc.gmk。</p>

<p>(10) 下面就可以进入openjdk目录进行编译了。</p>

<p>首先输入bash进入cygwin环境，然后输入make sanity进行环境变量检查，如果回显输出make sanity pass就可以继续了，如果出错那么需要回头检查一下之前的设置是否正确。最后输入make进行编译即可。当然还有可能出错，那就要仔细查看错误输出再尝试解决了。</p>

<p>我的机器是i5 3470 + 16G，在虚拟机中分配了1G的RAM（如果你的RAM小于512M，编译的时候工具会提醒你也许会很耗时），总共用了半个小时多一点编译完成。</p>

<p>-EOF-</p>]]></content><author><name></name></author><category term="openjdk" /><category term="compile" /><category term="windows" /><category term="make" /><category term="cygwin" /><summary type="html"><![CDATA[Windows下编译OpenJDK7 笔记]]></summary></entry></feed>